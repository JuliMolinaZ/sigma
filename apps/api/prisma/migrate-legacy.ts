
import { PrismaClient, PaymentStatus, QuoteStatus, RequisitionStatus } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';

const prisma = new PrismaClient();

// Helper to parse SQL INSERT statements
function parseInsertValues(sql: string, tableName: string): any[][] {
    const regex = new RegExp(`INSERT INTO \`${tableName}\` VALUES (.*);`, 'g');
    const match = regex.exec(sql);
    if (!match) return [];

    const valuesStr = match[1];
    const rows: any[][] = [];
    let currentRow: any[] = [];
    let currentVal = '';
    let inQuote = false;
    let isEscaped = false;

    // Simple parser for SQL value lists like (1, 'text', NULL), (2, ...)
    for (let i = 0; i < valuesStr.length; i++) {
        const char = valuesStr[i];

        if (inQuote) {
            if (char === "'" && !isEscaped) {
                inQuote = false;
            } else if (char === '\\' && !isEscaped) {
                isEscaped = true;
            } else {
                isEscaped = false;
                currentVal += char;
            }
        } else {
            if (char === '(' && currentRow.length === 0 && currentVal.trim() === '') {
                // Start of row
                currentRow = [];
            } else if (char === ')' && currentRow.length >= 0) {
                // End of row
                if (currentVal.trim() !== '') {
                    currentRow.push(parseValue(currentVal));
                }
                rows.push(currentRow);
                currentRow = [];
                currentVal = '';
            } else if (char === ',') {
                if (currentRow.length >= 0 && currentVal.trim() !== '') { // Inside a row
                    currentRow.push(parseValue(currentVal));
                    currentVal = '';
                } else if (currentRow.length === 0) {
                    // Comma between rows, ignore
                }
            } else if (char === "'") {
                inQuote = true;
            } else {
                currentVal += char;
            }
        }
    }
    return rows;
}

function parseValue(val: string): any {
    val = val.trim();
    if (val === 'NULL') return null;
    if (val.startsWith("'") && val.endsWith("'")) return val.slice(1, -1);
    if (!isNaN(Number(val))) return Number(val);
    return val;
}

// Improved parser that handles the specific structure of the dump better
function extractTableData(sqlContent: string, tableName: string): any[] {
    const insertPrefix = `INSERT INTO \`${tableName}\` VALUES `;
    const startIndex = sqlContent.indexOf(insertPrefix);
    if (startIndex === -1) return [];

    let dataPart = sqlContent.substring(startIndex + insertPrefix.length);
    const endStatementIndex = dataPart.indexOf(';');
    dataPart = dataPart.substring(0, endStatementIndex);

    // Split by "),(" but be careful about quoted strings containing that pattern
    // Since this is a one-off migration script, we can use a slightly more robust regex approach
    // or just split and clean up if we assume standard mysqldump format

    // Regex to match (...) groups
    const rowRegex = /\((?:[^)(]+|\((?:[^)(]+|\([^)(]*\))*\))*\)/g;
    // This simple regex might fail on nested parenthesis in text, but standard dumps usually escape them.
    // Let's try a manual state machine parser for the whole values string which is safer.

    const rows: any[] = [];
    let currentRow: any[] = [];
    let currentToken = '';
    let inString = false;
    let inParens = 0;

    for (let i = 0; i < dataPart.length; i++) {
        const char = dataPart[i];

        if (inString) {
            if (char === "'" && dataPart[i - 1] !== '\\') {
                inString = false;
            }
            currentToken += char;
        } else {
            if (char === "'") {
                inString = true;
                currentToken += char;
            } else if (char === '(') {
                if (inParens === 0) {
                    // Start of row
                    currentRow = [];
                    currentToken = '';
                } else {
                    currentToken += char;
                }
                inParens++;
            } else if (char === ')') {
                inParens--;
                if (inParens === 0) {
                    // End of row
                    if (currentToken.trim()) {
                        currentRow.push(cleanValue(currentToken));
                    }
                    rows.push(currentRow);
                    currentRow = [];
                    currentToken = '';
                } else {
                    currentToken += char;
                }
            } else if (char === ',') {
                if (inParens === 1) {
                    // Field separator
                    currentRow.push(cleanValue(currentToken));
                    currentToken = '';
                } else {
                    currentToken += char;
                }
            } else {
                currentToken += char;
            }
        }
    }
    return rows;
}

function cleanValue(val: string): any {
    val = val.trim();
    if (val === 'NULL') return null;
    if (val.startsWith("'") && val.endsWith("'")) {
        // Remove quotes and unescape
        val = val.substring(1, val.length - 1);
        val = val.replace(/\\'/g, "'").replace(/\\"/g, '"').replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r');
        return val;
    }
    if (!isNaN(Number(val))) return Number(val);
    return val;
}


async function main() {
    console.log('ðŸš€ Starting Legacy Migration...');

    const sqlPath = path.join(__dirname, '../../../docs/runite_backup.sql');
    if (!fs.existsSync(sqlPath)) {
        console.error('âŒ SQL dump not found at:', sqlPath);
        process.exit(1);
    }

    const sqlContent = fs.readFileSync(sqlPath, 'utf-8');

    // 1. Ensure Organization
    console.log('ðŸ¢ Setting up Organization...');
    let org = await prisma.organization.findFirst({ where: { slug: 'runite-legacy' } });
    if (!org) {
        // Try to find default one or create new
        org = await prisma.organization.findFirst();
        if (!org) {
            org = await prisma.organization.create({
                data: {
                    name: 'Runite Legacy',
                    slug: 'runite-legacy',
                }
            });
        }
    }
    const orgId = org.id;
    console.log(`âœ… Using Organization: ${org.name} (${orgId})`);

    // 2. Users
    console.log('ðŸ‘¤ Migrating Users...');
    const usersData = extractTableData(sqlContent, 'users');
    // Structure: id, firebase_uid, email, name, avatar, created_at, updated_at, role
    for (const row of usersData) {
        const [id, firebase_uid, email, name, avatar, created_at, updated_at, roleName] = row;

        // Split name
        const nameParts = (name || '').split(' ');
        const firstName = nameParts[0] || 'Unknown';
        const lastName = nameParts.slice(1).join(' ') || '';

        await prisma.user.upsert({
            where: {
                email_organizationId: {
                    email: email,
                    organizationId: orgId
                }
            },
            update: {
                legacyUserId: id,
                organizationId: orgId,
            },
            create: {
                email: email,
                firstName: firstName,
                lastName: lastName,
                password: 'Runite2025!', // Default password
                organization: { connect: { id: orgId } }, // Fixed: Mixed scalar/relation
                legacyUserId: id,
                role: {
                    connectOrCreate: {
                        where: {
                            name_organizationId: {
                                name: roleName || 'Employee',
                                organizationId: orgId
                            }
                        },
                        create: {
                            name: roleName || 'Employee',
                            description: `Legacy role: ${roleName}`,
                            organization: { connect: { id: orgId } }
                        }
                    }
                }
            }
        });
    }
    console.log(`âœ… Migrated ${usersData.length} Users`);

    // 3. Clients
    console.log('ðŸ¤ Migrating Clients...');
    const clientsData = extractTableData(sqlContent, 'clients');
    // Structure: id, run_cliente, nombre, rfc, direccion, created_at, updated_at
    for (const row of clientsData) {
        const [id, run_cliente, nombre, rfc, direccion] = row;

        await prisma.client.upsert({
            where: { legacyClientId: id },
            update: {},
            create: {
                nombre: nombre || 'Unknown Client', // Fixed: name -> nombre
                runCliente: run_cliente, // Fixed: code -> runCliente
                rfc: rfc,
                direccion: direccion, // Fixed: address -> direccion
                organizationId: orgId,
                legacyClientId: id,
            }
        });
    }
    console.log(`âœ… Migrated ${clientsData.length} Clients`);

    // 4. Suppliers
    console.log('ðŸšš Migrating Suppliers...');
    const suppliersData = extractTableData(sqlContent, 'proveedores');
    // Structure: id, run_proveedor, nombre, direccion, elemento, datos_bancarios, contacto
    for (const row of suppliersData) {
        const [id, run_proveedor, nombre, direccion, elemento, datos_bancarios, contacto] = row;

        await prisma.supplier.upsert({
            where: { legacySupplierId: id },
            update: {},
            create: {
                nombre: nombre || 'Unknown Supplier', // Fixed: name -> nombre
                runProveedor: run_proveedor, // Fixed: code -> runProveedor
                direccion: direccion, // Fixed: address -> direccion
                contacto: contacto, // Fixed: contactName -> contacto
                datosBancarios: datos_bancarios, // Fixed: bankDetails -> datosBancarios
                // category: elemento, // Removed: category not in Supplier model? Check schema.
                organizationId: orgId,
                legacySupplierId: id,
            }
        });
    }
    console.log(`âœ… Migrated ${suppliersData.length} Suppliers`);

    // 5. Phases
    console.log('ðŸ”„ Migrating Phases...');
    const phasesData = extractTableData(sqlContent, 'phases');
    // Structure: id, nombre, descripcion
    for (const row of phasesData) {
        const [id, nombre, descripcion] = row;

        await prisma.phase.upsert({
            where: { legacyPhaseId: id },
            update: {},
            create: {
                name: nombre,
                description: descripcion,
                organizationId: orgId,
                legacyPhaseId: id,
                color: '#3B82F6' // Default color
            }
        });
    }
    console.log(`âœ… Migrated ${phasesData.length} Phases`);

    // 6. Projects
    console.log('ðŸš€ Migrating Projects...');
    const projectsData = extractTableData(sqlContent, 'projects');
    // Structure: id, nombre, cliente_id, monto_sin_iva, monto_con_iva, created_at, updated_at, phase_id
    for (const row of projectsData) {
        const [id, nombre, cliente_id, monto_sin_iva, monto_con_iva, created_at, updated_at, phase_id] = row;

        // Find client UUID
        const client = await prisma.client.findUnique({ where: { legacyClientId: cliente_id } });
        // Find phase UUID
        const phase = phase_id ? await prisma.phase.findUnique({ where: { legacyPhaseId: phase_id } }) : null;

        await prisma.project.upsert({
            where: { legacyProjectId: id },
            update: {},
            create: {
                name: nombre || 'Unnamed Project',
                description: `Legacy Project (ID: ${id})`,
                amountWithTax: monto_con_iva || 0, // Fixed: totalAmount -> amountWithTax
                amountWithoutTax: monto_sin_iva || 0, // Added
                organizationId: orgId,
                legacyProjectId: id,
                clientId: client?.id,
                phaseId: phase?.id,
                status: 'ACTIVE', // Default
                startDate: created_at ? new Date(created_at) : new Date(),
                ownerId: (await prisma.user.findFirst({ where: { organizationId: orgId } }))?.id || '', // Required field ownerId
            }
        });
    }
    console.log(`âœ… Migrated ${projectsData.length} Projects`);

    // 7. Accounts Receivable (Cuentas por Cobrar)
    console.log('ðŸ’° Migrating Accounts Receivable...');
    const arData = extractTableData(sqlContent, 'cuentas_por_cobrar');
    // Structure: id, proyecto_id, concepto, monto_sin_iva, monto_con_iva, fecha
    for (const row of arData) {
        const [id, proyecto_id, concepto, monto_sin_iva, monto_con_iva, fecha] = row;

        const project = await prisma.project.findUnique({ where: { legacyProjectId: proyecto_id } });

        const montoTotal = monto_con_iva || monto_sin_iva || 0;

        await prisma.accountReceivable.upsert({
            where: { legacyAccountReceivableId: id },
            update: {
                concepto: concepto,
                monto: montoTotal,
                montoRestante: montoTotal, // Default to full amount, will be adjusted by payments
                fechaVencimiento: fecha ? new Date(fecha) : new Date(),
                status: 'PENDING',
                projectId: project?.id || '',
            },
            create: {
                concepto: concepto,
                monto: montoTotal,
                montoRestante: montoTotal,
                fechaVencimiento: fecha ? new Date(fecha) : new Date(),
                status: 'PENDING',
                organizationId: orgId,
                legacyAccountReceivableId: id,
                projectId: project?.id || '',
            }
        });
    }
    console.log(`âœ… Migrated ${arData.length} Accounts Receivable`);

    // 8. Payment Complements (Complementos de Pago)
    console.log('ðŸ’µ Migrating Payment Complements...');
    const pcData = extractTableData(sqlContent, 'complementos_pago');
    // Structure: id, cuenta_id, fecha_pago, concepto, monto_sin_iva, monto_con_iva
    for (const row of pcData) {
        const [id, cuenta_id, fecha_pago, concepto, monto_sin_iva, monto_con_iva] = row;

        const ar = await prisma.accountReceivable.findUnique({ where: { legacyAccountReceivableId: cuenta_id } });

        if (ar) {
            await prisma.paymentComplement.upsert({
                where: { legacyPaymentComplementId: id },
                update: {},
                create: {
                    monto: monto_con_iva || 0, // Fixed: amount -> monto
                    fechaPago: fecha_pago ? new Date(fecha_pago) : new Date(), // Fixed: date -> fechaPago
                    accountReceivableId: ar.id,
                    organizationId: orgId,
                    legacyPaymentComplementId: id,
                    cfdiUrl: '', // Fixed: pdfUrl -> cfdiUrl? No, schema has cfdiUrl
                    // xmlUrl: ''  // Placeholder
                }
            });
        }
    }
    console.log(`âœ… Migrated ${pcData.length} Payment Complements`);

    // 9. Accounts Payable (Cuentas por Pagar)
    console.log('ðŸ’¸ Migrating Accounts Payable...');
    const apData = extractTableData(sqlContent, 'cuentas_por_pagar');
    // Structure: id, concepto, monto_neto, monto_con_iva, categoria, proveedor_id, fecha, pagado
    for (const row of apData) {
        const [id, concepto, monto_neto, monto_con_iva, categoria, proveedor_id, fecha, pagado] = row;

        const supplier = proveedor_id ? await prisma.supplier.findUnique({ where: { legacySupplierId: proveedor_id } }) : null;

        const montoTotal = monto_con_iva || monto_neto || 0;
        const isPaid = !!pagado;
        const montoPagado = isPaid ? montoTotal : 0;
        const montoRestante = isPaid ? 0 : montoTotal;

        await prisma.accountPayable.upsert({
            where: { legacyAccountPayableId: id },
            update: {
                concepto: concepto,
                monto: montoTotal,
                fechaVencimiento: fecha ? new Date(fecha) : null,
                status: isPaid ? PaymentStatus.PAID : PaymentStatus.PENDING,
                pagado: isPaid,
                montoPagado: montoPagado,
                montoRestante: montoRestante,
                supplierId: supplier?.id,
                notas: `Categoria Legacy: ${categoria}`
            },
            create: {
                concepto: concepto,
                monto: montoTotal,
                fechaVencimiento: fecha ? new Date(fecha) : null,
                status: isPaid ? PaymentStatus.PAID : PaymentStatus.PENDING,
                pagado: isPaid,
                montoPagado: montoPagado,
                montoRestante: montoRestante,
                organizationId: orgId,
                legacyAccountPayableId: id,
                supplierId: supplier?.id,
                notas: `Categoria Legacy: ${categoria}`
            }
        });
    }
    console.log(`âœ… Migrated ${apData.length} Accounts Payable`);

    // 10. Fixed Costs (Costos Fijos)
    console.log('ðŸ“‰ Migrating Fixed Costs...');
    const fcData = extractTableData(sqlContent, 'costos_fijos');
    // Structure: id, colaborador, puesto, monto_usd, monto_mxn, impuestos_imss, comentarios, ..., fecha, cuenta_creada
    for (const row of fcData) {
        const [id, colaborador, puesto, monto_usd, monto_mxn, impuestos_imss, comentarios, created_at, updated_at, fecha] = row;

        await prisma.fixedCost.upsert({
            where: { legacyFixedCostId: id },
            update: {},
            create: {
                nombre: colaborador,
                categoria: puesto || 'General',
                monto: monto_mxn || 0,
                periodicidad: 'Mensual', // Assumed
                diaVencimiento: fecha ? new Date(fecha).getDate() : 1,
                isActive: true,
                notas: comentarios,
                organizationId: orgId,
                legacyFixedCostId: id,
            }
        });
    }
    console.log(`âœ… Migrated ${fcData.length} Fixed Costs`);

    // 11. Invoices (Emitidas)
    console.log('ðŸ§¾ Migrating Invoices...');
    const invData = extractTableData(sqlContent, 'emitidas');
    // Structure: id, rfcReceptor, razonSocial, fechaEmision, subtotal, iva, total, claveSat, descripcion, ...
    for (const row of invData) {
        const [id, rfcReceptor, razonSocial, fechaEmision, subtotal, iva, total, claveSat, descripcion] = row;

        await prisma.invoice.upsert({
            where: { legacyInvoiceId: id },
            update: {},
            create: {
                // rfcReceptor, // Removed: Not in schema
                // razonSocial, // Removed: Not in schema
                number: `INV-${id}`, // Required field
                amount: total || 0, // Required field
                dueDate: new Date(fechaEmision), // Required field
                issueDate: new Date(fechaEmision),
                subtotal: subtotal || 0,
                tax: iva || 0,
                total: total || 0,
                // descripcion, // Removed: Not in schema? Check schema.
                organizationId: orgId,
                legacyInvoiceId: id,
                status: 'PAID', // Default assumption
                documents: {
                    legacy_rfc: rfcReceptor,
                    legacy_razonSocial: razonSocial,
                    legacy_descripcion: descripcion
                }
            }
        });
    }
    console.log(`âœ… Migrated ${invData.length} Invoices`);

    // 12. Recoveries (Recuperacion)
    console.log('ðŸ”„ Migrating Recoveries...');
    const recData = extractTableData(sqlContent, 'recuperacion');
    // Structure: id, concepto, monto, fecha, cliente_id, proyecto_id, ...
    for (const row of recData) {
        const [id, concepto, monto, fecha, cliente_id, proyecto_id] = row;

        const client = await prisma.client.findUnique({ where: { legacyClientId: cliente_id } });
        const project = await prisma.project.findUnique({ where: { legacyProjectId: proyecto_id } });

        if (client) {
            await prisma.recovery.upsert({
                where: { legacyRecoveryId: id },
                update: {},
                create: {
                    descripcion: concepto,
                    montoEsperado: monto || 0,
                    fechaInicio: fecha ? new Date(fecha) : new Date(),
                    clientId: client.id,
                    projectId: project?.id,
                    organizationId: orgId,
                    legacyRecoveryId: id,
                }
            });
        }
    }
    console.log(`âœ… Migrated ${recData.length} Recoveries`);

    // 13. Requisitions (Requisiciones)
    console.log('ðŸ“ Migrating Requisitions...');
    const reqData = extractTableData(sqlContent, 'requisiciones');
    // Structure: id, concepto, solicitante, justificacion, area, fecha_requerida, costos, ...
    for (const row of reqData) {
        const [id, concepto, solicitante, justificacion, area, fecha_requerida, costos] = row;

        await prisma.requisition.upsert({
            where: { legacyRequisitionId: id },
            update: {},
            create: {
                descripcion: concepto,
                monto: costos || 0,
                fechaSolicitud: new Date(), // Missing in source?
                fechaRequerida: fecha_requerida ? new Date(fecha_requerida) : null,
                status: RequisitionStatus.APPROVED, // Assuming approved based on dump data
                notas: `${justificacion} (Solicitante: ${solicitante}, Area: ${area})`,
                organizationId: orgId,
                legacyRequisitionId: id,
            }
        });
    }
    console.log(`âœ… Migrated ${reqData.length} Requisitions`);

    // 14. Quotes (Cotizaciones)
    console.log('ðŸ’¬ Migrating Quotes...');
    const quoteData = extractTableData(sqlContent, 'cotizaciones');
    // Structure: id, cliente, proyecto, monto_neto, monto_con_iva, descripcion, documento, estado
    for (const row of quoteData) {
        const [id, cliente_id_str, proyecto_id_str, monto_neto, monto_con_iva, descripcion, documento, estado] = row;

        const clientId = parseInt(cliente_id_str);
        const projectId = parseInt(proyecto_id_str);

        const client = !isNaN(clientId) ? await prisma.client.findUnique({ where: { legacyClientId: clientId } }) : null;
        const project = !isNaN(projectId) ? await prisma.project.findUnique({ where: { legacyProjectId: projectId } }) : null;

        let status: QuoteStatus = QuoteStatus.DRAFT;
        if (estado === 'Aceptada por cliente') status = QuoteStatus.ACCEPTED;
        if (estado === 'No aceptada') status = QuoteStatus.REJECTED;
        if (estado === 'En proceso de aceptaciÃ³n') status = QuoteStatus.SENT;

        await prisma.quote.upsert({
            where: { legacyQuoteId: id },
            update: {},
            create: {
                numero: `QT-${id}`,
                descripcion: descripcion,
                subtotal: monto_neto || 0,
                iva: (monto_con_iva - monto_neto) || 0,
                total: monto_con_iva || 0,
                status: status,
                pdfUrl: documento,
                organizationId: orgId,
                legacyQuoteId: id,
                clientId: client?.id,
                projectId: project?.id,
            }
        });
    }
    console.log(`âœ… Migrated ${quoteData.length} Quotes`);

    console.log('ðŸŽ‰ Migration Complete!');
}

main()
    .catch((e) => {
        console.error(e);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });
